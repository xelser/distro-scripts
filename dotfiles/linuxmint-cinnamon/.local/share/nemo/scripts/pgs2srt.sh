#!/bin/bash
clear

ROOT="${1:-$PWD}"
LOG="$ROOT/subtitle_ocr_pipeline.log"
COMMENT="[OCR] Generated by Subtitle OCR Pipeline" # Generalized COMMENT for generic footer validation
orphan_log="$ROOT/orphaned_srt_audit.log"

# Global flag to track overall script success
SCRIPT_SUCCESS=true

# â”€â”€ Colors for terminal only â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
GREEN='\033[0;32m' ; YELLOW='\033[1;33m' ; BLUE='\033[1;34m'
RED='\033[0;31m'   ; PURPLE='\033[0;35m' ; TEAL='\033[0;36m'
ORANGE='\033[38;5;208m' ; NC='\033[0m'

# â”€â”€ Logging Functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
timestamp() { date +"[%Y-%m-%d %H:%M:%S]" ; }

# log_msg: Prints to stdout AND appends to log file
log_msg() {
  local msg="$1"
  echo -e "$msg" # Print to terminal
  echo -e "$(timestamp) ${msg//$NC/}" >> "$LOG" # Append to log file (stripping color codes)
}

# log_file_only_msg: Appends ONLY to log file
log_file_only_msg() {
  local msg="$1"
  echo -e "$(timestamp) ${msg//$NC/}" >> "$LOG" # Append to log code (stripping color codes)
}

function notify() {
  if command -v notify-send &>/dev/null && [[ -n "${DISPLAY:-}" ]]; then
    notify-send "Subtitle OCR Pipeline" "$1" # Updated notification title
  else
    log_msg "${YELLOW}[!] Desktop notification unavailable${NC}" # Use log_msg for consistency
  fi
  # Log the notification message using log_msg, which now handles both stdout and file logging
  log_msg "${BLUE}[ðŸ””] $1${NC}"
}

# â”€â”€ Initial Cleanup of Old Logs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
log_msg "${BLUE}â”€ Cleaning up old log files... â”€${NC}"
rm -f "$LOG" "$orphan_log" >> /dev/null 2>&1
log_msg "${GREEN}âœ” Old log files removed.${NC}"

# â”€â”€ Initial Scan Message â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
log_msg "${BLUE}â”€ Starting Subtitle OCR scan in: $ROOT â”€${NC}" # Generalized message

# â”€â”€ Dependency Lists â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CLI_DEPS: Tools directly used as commands in the main script logic.
# Removed maven and default-jdk as BDSup2Sub is being removed.
CLI_DEPS=(mkvtoolnix jq tesseract-ocr libnotify-bin)

# BUILD_DEPS: Libraries and tools required to compile sup2srt from source.
# Removed vobsub2srt related build dependencies as VobSub support is being removed.
BUILD_DEPS=(libtiff5-dev libleptonica-dev libtesseract-dev tesseract-ocr-eng \
            libavcodec-dev libavformat-dev libavutil-dev libavdevice-dev \
            cmake build-essential git libpng-dev zlib1g-dev pkg-config)

# Removed BDSUP2SUB_DIR and BDSUP2SUB_JAR_PATH as BDSup2Sub is being removed.

# â”€â”€ Dependency Check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
log_msg "${BLUE}â”€ Checking and installing system dependencies â”€${NC}"
missing_apt_deps=()

# Check for CLI dependencies
for pkg in "${CLI_DEPS[@]}"; do
  dpkg -s "$pkg" &>/dev/null || missing_apt_deps+=("$pkg")
done

# Check for build dependencies
for dep in "${BUILD_DEPS[@]}"; do
  dpkg -s "$dep" &>/dev/null || missing_apt_deps+=("$dep")
done

if (( ${#missing_apt_deps[@]} )); then
  log_msg "${YELLOW}[+] Installing missing APT packages: ${missing_apt_deps[*]}${NC}"
  sudo DEBIAN_FRONTEND=noninteractive apt install -y "${missing_apt_deps[@]}" >> "$LOG" 2>&1
  if [ $? -ne 0 ]; then
    log_msg "${RED} âœ— Failed to install APT dependencies. Please check the log for details.${NC}"
    SCRIPT_SUCCESS=false
  fi
  # Update dynamic linker cache after installing new libraries
  log_msg "${TEAL} â†ª Updating dynamic linker cache (ldconfig)...${NC}"
  sudo ldconfig >> "$LOG" 2>&1
else
  log_msg "${GREEN}âœ” All core APT dependencies present.${NC}"
fi

# Removed: â”€â”€ Build BDSup2Sub if missing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# â”€â”€ Build sup2srt if missing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
if "$SCRIPT_SUCCESS"; then # Only proceed if previous steps were successful
  log_msg "${BLUE}â”€ Checking for sup2srt â”€${NC}"
  if ! command -v sup2srt &>/dev/null; then
    log_msg "${RED}[!] sup2srt not found. Attempting to build from source...${NC}"

    # Clean up previous build directory if it exists
    if [[ -d "/tmp/sup2srt" ]]; then
      log_msg "${TEAL} â†ª Cleaning up existing /tmp/sup2srt directory...${NC}"
      rm -rf "/tmp/sup2srt" >> "$LOG" 2>&1
    fi

    log_msg "${TEAL} â†ª Cloning sup2srt repository${NC}"
    git clone https://github.com/retrontology/sup2srt.git /tmp/sup2srt >> "$LOG" 2>&1
    if [ $? -ne 0 ]; then
      log_msg "${RED} âœ— Failed to clone sup2srt repository. Please check the log for details.${NC}"
      SCRIPT_SUCCESS=false
    fi

    if "$SCRIPT_SUCCESS"; then # Only proceed with build if clone was successful
      log_msg "${TEAL} â†ª Building sup2srt${NC}"
      mkdir -p /tmp/sup2srt/build && cd /tmp/sup2srt/build
      cmake .. >> "$LOG" 2>&1 && make -j"$(nproc)" >> "$LOG" 2>&1 && sudo make install >> "$LOG" 2>&1
      if [ $? -ne 0 ]; then
        log_msg "${RED} âœ— Failed to build and install sup2srt. Please check the log for details.${NC}"
        SCRIPT_SUCCESS=false
      fi
      cd "$ROOT" # Return to the original root directory
    fi

    if "$SCRIPT_SUCCESS" && command -v sup2srt &>/dev/null; then
      log_msg "${GREEN}âœ” sup2srt built and installed successfully.${NC}"
    elif ! "$SCRIPT_SUCCESS"; then
      log_msg "${RED} âœ— sup2srt not installed due to previous errors.${NC}"
    else
      log_msg "${RED} âœ— sup2srt still not found after build attempt. Please check the log for details.${NC}"
      SCRIPT_SUCCESS=false
    fi
  else
    log_msg "${GREEN}âœ” sup2srt is already installed.${NC}"
  fi
fi

# Removed: â”€â”€ Build vobsub2srt from moisespr123/VobSub2SRT fork if missing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

# â”€â”€ Main Script Logic Starts Here â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

if "$SCRIPT_SUCCESS"; then # Only proceed with main logic if all installations were successful
  EXCLUDE_FILE="/mnt/Media/srt_exclude_dirs.txt"
  excluded=()
  # Read excluded directories into an array if the file exists
  [[ -f "$EXCLUDE_FILE" ]] && mapfile -t excluded < "$EXCLUDE_FILE"

  # Global array to store full paths of all SRTs that should remain after this run
  declare -a processed_srt_paths=()

  # Find all MKV files recursively
  mapfile -t mkv_list < <(find "$ROOT" -iname "*.mkv")
  total=${#mkv_list[@]}
  processed=0

  for mkvfile in "${mkv_list[@]}"; do
    ((processed++))
    # Calculate percentage complete
    percent=$(( processed * 100 / total ))
    dir=$(dirname "$mkvfile")
    base="$(basename "${mkvfile%.*}")" # Filename without extension
    parent="$(basename "$dir")" # Parent directory name

    echo -e "\n" # Add a newline for better readability between files
    log_msg "${BLUE}âž¤ Processing [$processed/$total] â†’ ${percent}% done${NC}"
    log_msg "${PURPLE} â€¢ $base.mkv${NC}"

    # Check if the parent directory is in the exclusion list
    if printf '%s\n' "${excluded[@]}" | grep -qxF "$parent"; then
      log_msg "${YELLOW} â†ª Directory excluded â†’ Skipping${NC}"
      continue
    fi

    # Check for embedded SRT or ASS tracks using mkvmerge info
    if mkvmerge -i "$mkvfile" | grep -Ei 'subtitles.*(SRT|ASS)' >/dev/null; then
      log_msg "${YELLOW} â†ª Skipped: Embedded SRT/ASS track${NC}"
      continue
    fi

    # Extract English or untagged PGS subtitle tracks using jq for precise filtering
    # Updated jq filter to only select HDMV PGS tracks.
    pgs_tracks=$(mkvmerge -J "$mkvfile" | jq '[.tracks[] | select(.type=="subtitles" and .codec=="HDMV PGS" and (.properties.language == "eng" or .properties.language == null))]')
    mapfile -t track_lines < <(jq -c '.[]' <<< "$pgs_tracks") # Convert JSON array to bash array of lines
    
    # If no usable PGS tracks are found, skip to the next MKV
    [[ ${#track_lines[@]} -eq 0 ]] && {
      log_msg "${RED} âœ— No usable English PGS subtitle tracks${NC}"
      continue
    }

    created_subs=() # Initialize array to track created/skipped subtitles for the current MKV
    en_regular_count=0 # IMPORTANT: Reset for each MKV file
    en_forced_count=0  # IMPORTANT: Reset for each MKV file
    en_sdh_count=0     # IMPORTANT: Reset for each MKV file

    for track in "${track_lines[@]}"; do
      id=$(echo "$track" | jq '.id') # Extract track ID
      codec=$(echo "$track" | jq -r '.codec') # Extract codec type (HDMV PGS)
      title=$(echo "$track" | jq -r '.properties.track_name // ""') # Extract track name, default to empty string
      # Extract forced_track and hearing_impaired flags directly from metadata
      forced_flag=$(echo "$track" | jq '.properties.forced_track // false')
      hearing_impaired_flag=$(echo "$track" | jq '.properties.hearing_impaired // false')

      # ðŸ”¤ Suffix inference from track title AND metadata flags
      local_base_suffix=""
      local_is_forced=false
      local_is_sdh=false

      # Prioritize forced flag/title, then SDH flag/title, then regular
      if [[ "$forced_flag" == "true" || "$title" =~ [Ff]orced ]]; then
          local_base_suffix=".en.forced"
          local_is_forced=true
      elif [[ "$hearing_impaired_flag" == "true" || "$title" =~ (SDH|HI|HOH|Hearing Impaired) ]]; then
          local_base_suffix=".en.sdh"
          local_is_sdh=true
      else
          local_base_suffix=".en" # Default for regular English tracks
      fi

      # Determine the final suffix_key based on type and count
      if [ "$local_is_forced" == "true" ]; then
          ((en_forced_count++))
          if [ "$en_forced_count" -eq 1 ]; then
              suffix_key="${local_base_suffix#.}" # "en.forced"
          else
              suffix_key="${local_base_suffix#.}.${en_forced_count}" # "en.forced.2"
          fi
      elif [ "$local_is_sdh" == "true" ]; then
          ((en_sdh_count++))
          if [ "$en_sdh_count" -eq 1 ]; then
              suffix_key="${local_base_suffix#.}" # "en.sdh"
          else
              suffix_key="${local_base_suffix#.}.${en_sdh_count}" # "en.sdh.2"
          fi
      else # Regular English track
          ((en_regular_count++))
          if [ "$en_regular_count" -eq 1 ]; then
              suffix_key="${local_base_suffix#.}" # "en"
          else
              suffix_key="${local_base_suffix#.}.${en_regular_count}" # "en.2"
          fi
      fi

      srt="$dir/$base.$suffix_key.srt" # Proposed SRT filename
      
      # Define temporary file paths based on codec
      temp_files=()
      
      # Validation block: Check if a valid OCR'd SRT already exists for THIS specific track configuration
      if [[ -f "$srt" ]]; then
        footer=$(tail -n 1 "$srt" 2>/dev/null || echo "") # Get last line, handle empty file
        
        # Use the generic COMMENT for expected_footer comparison
        expected_footer="$COMMENT" 

        # Debugging log:
        # log_msg "${TEAL}  [DEBUG] Validating $srt: Footer='${footer}' Expected='${expected_footer}'${NC}"

        # If the file exists and has our generic comment, it's considered valid and processed
        if [[ "$footer" == "$expected_footer" ]]; then
          log_msg "${YELLOW} â†ª Valid OCR exists â†’ $(basename "$srt")${NC}"
          created_subs+=("Skipped: .$suffix_key.srt") # Store concise skipped info
          processed_srt_paths+=("$srt") # Add to global list of valid SRTs
          continue # Skip to next track
        else
          # If file exists but does NOT have our generic comment, it's an external/invalid file at this path
          log_msg "${ORANGE} â†ª Conflicting untagged SRT found, removing: $(basename "$srt")${NC}"
          rm -f "$srt"
          # Changed this line to only write to orphan_log and not stdout
          echo "$(timestamp) [CONFLICT-REMOVED] Removed: $(basename "$srt")" >> "$orphan_log"
        fi
      fi

      # Suffix conflict resolution: This block handles cases where the *generated* SRT name
      # still conflicts with an existing file (e.g., a pre-existing manual file, or an edge case).
      # It appends a further numerical index to ensure uniqueness.
      if [[ -f "$srt" ]]; then
        local current_base_name="$dir/$base.$suffix_key" # e.g., /path/to/movie.en or /path/to/movie.en.forced
        local conflict_index=2
        while [[ -f "${current_base_name}.${conflict_index}.srt" ]]; do
          ((conflict_index++))
        done
        suffix_key="${suffix_key}.${conflict_index}" # Append .2, .3 etc. to the current suffix_key
        srt="$dir/$base.$suffix_key.srt"
      fi

      # ðŸ§ª Extract and OCR process based on codec (now only PGS)
      log_msg "${TEAL}  â†ª Extracting track $id ($codec) from .mkv via mkvextract${NC}"
      if [[ "$codec" == "HDMV PGS" ]]; then
        temp_sup="${srt%.srt}.sup"
        mkvextract tracks "$mkvfile" "$id:$temp_sup" >> "$LOG" 2>&1
        log_msg "${GREEN}  âœ” Created:${NC} $(basename "$temp_sup")"
        log_msg "${TEAL}  â†ª Converting from .sup (PGS) to .srt (SubRip) via sup2srt${NC}"
        sup2srt -l eng "$temp_sup" -o "$srt" >> "$LOG" 2>&1
        # Retry sup2srt if output is empty or too short (less than 6 lines for a valid SRT)
        if [[ ! -s "$srt" || $(wc -l < "$srt") -lt 6 ]]; then
          log_msg "${ORANGE} â†» Retry: sup2srt fallback (without -l eng) â†’ Track $id${NC}"
          sup2srt "$temp_sup" -o "$srt" >> "$LOG" 2>&1 # Retry without language flag
        fi
        temp_files+=("$temp_sup") # Add for cleanup
      else # This block will now catch any non-PGS tracks that somehow passed the jq filter (shouldn't happen with updated filter)
        log_msg "${RED} âœ— Unsupported codec '$codec' for track $id. Skipping OCR for this track.${NC}"
        continue # Skip to next track
      fi

      # Final check after OCR attempt
      if [[ -s "$srt" && $(wc -l < "$srt") -gt 5 ]]; then
        block_count=$(grep -cE '^[0-9]+$' "$srt") # Recalculate block count for footer
        # Append only the generic COMMENT to the SRT file
        echo -e "\n9999\n99:59:59,999 --> 99:59:59,999\n$COMMENT" >> "$srt"
        chmod 664 "$srt" && chown "$USER:mediaaccess" "$srt" # Set permissions and ownership
        
        # Clean up temporary files based on codec
        for temp_file in "${temp_files[@]}"; do
          rm -f "$temp_file"
        done
        log_msg "${GREEN}  âœ” Created:${NC} $(basename "$srt")${NC}"
        created_subs+=(".$suffix_key.srt") # Store concise created info
        processed_srt_paths+=("$srt") # Add to global list of valid SRTs
      else
        log_msg "${RED} âœ— OCR failed for Track $id ($codec). Please check the log for details.${NC}"
        SCRIPT_SUCCESS=false # Mark overall script as failed
        # Clean up temporary files even on failure
        for temp_file in "${temp_files[@]}"; do
          rm -f "$temp_file"
        done
      fi
    done

    # Summarize processing for the current MKV file in the log
    unique_subs=()
    mapfile -t unique_subs < <(printf "%s\n" "${created_subs[@]}" | awk '!seen[$0]++') # Get unique entries
    new_files=()
    for sub in "${unique_subs[@]}"; do
      new_files+=("$sub") # new_files now contains concise "Skipped: .en.forced.srt" or ".en.2.srt"
    done

    if [[ ${#new_files[@]} -gt 0 ]]; then
      log_file_only_msg "[SUMMARY][OCR] $base.mkv â†’ Created: $(IFS=,; echo "${new_files[*]}")"
    elif [[ ${#unique_subs[@]} -gt 0 ]]; then
      log_file_only_msg "[SUMMARY][SKIPPED] $base.mkv â†’ $(IFS=,; echo "${unique_subs[*]}")"
    else
      log_file_only_msg "[SUMMARY][FAILED] $base.mkv â†’ No usable output"
    fi
  done

  # ðŸ§¹ Final cleanup pass: delete any SRT not in processed_srt_paths (excluding filtered dirs)
  log_msg "${BLUE} ðŸ§¹ Final cleanup: Removing extraneous SRTs (excluding filtered directories)${NC}"
  cleaned=0
  # Find all SRT files in non-excluded directories
  find "$ROOT" -type f -iname "*.srt" | while read -r srt_file; do
    # Check if srt_file is in an excluded directory
    srt_parent_dir=$(basename "$(dirname "$srt_file")")
    if printf '%s\n' "${excluded[@]}" | grep -qxF "$srt_parent_dir"; then
      continue # Skip excluded directories
    fi

    # Check if this srt_file is NOT in our global list of known valid SRTs from this run
    # This is the core of the "delete if not explicitly kept" logic
    if ! (printf '%s\n' "${processed_srt_paths[@]}" | grep -qxF "$srt_file"); then
      rm -f "$srt_file"
      # Changed this line to only write to orphan_log and not stdout
      echo "$(timestamp) [FINAL-CLEANUP] Deleted: $(basename "$srt_file")" >> "$orphan_log"
    fi
  done

  if [[ $cleaned -gt 0 ]]; then
    log_msg "${RED} [INFO] Removed $cleaned extraneous SRTs.${NC}"
  else
    log_msg "${GREEN}âœ” No extraneous SRTs found for removal.${NC}"
  fi
else
  log_msg "${RED} âœ— Skipping main OCR processing due to previous dependency/build failures.${NC}"
fi

# ðŸŽ‰ Completion
if "$SCRIPT_SUCCESS"; then
  notify "Processing complete in $(basename "$ROOT")"
  log_msg "${GREEN}âœ” All tasks finished successfully. Log saved to:${NC} $LOG"
else
  notify "Processing finished with errors in $(basename "$ROOT")"
  log_msg "${RED}âœ— Script finished with errors. Please check the log file ($LOG) for details.${NC}"
fi

