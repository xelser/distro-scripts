#!/bin/bash
clear

ROOT="${1:-$PWD}"
LOG="$ROOT/pgs_recursive_pipeline.log"
COMMENT="[OCR] Generated by PGS OCR Pipeline" # Simplified COMMENT for generic footer validation
orphan_log="$ROOT/orphaned_srt_audit.log"

# â”€â”€ Dependency Lists â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
CLI_DEPS=(mkvtoolnix jq tesseract-ocr libnotify-bin)
SUP2SRT_DEPS=(libtiff-dev libleptonica-dev libtesseract-dev libavcodec-dev libavformat-dev libavutil-dev libavdevice-dev cmake build-essential git)

# â”€â”€ Colors for terminal only â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
GREEN='\033[0;32m' ; YELLOW='\033[1;33m' ; BLUE='\033[1;34m'
RED='\033[0;31m'   ; PURPLE='\033[0;35m' ; TEAL='\033[0;36m'
ORANGE='\033[38;5;208m' ; NC='\033[0m'

# â”€â”€ Logging Functions â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
timestamp() { date +"[%Y-%m-%d %H:%M:%S]" ; }

# log_msg: Prints to stdout AND appends to log file
log_msg() {
  local msg="$1"
  echo -e "$msg" # Print to terminal
  echo -e "$(timestamp) ${msg//$NC/}" >> "$LOG" # Append to log file (stripping color codes)
}

# log_file_only_msg: Appends ONLY to log file
log_file_only_msg() {
  local msg="$1"
  echo -e "$(timestamp) ${msg//$NC/}" >> "$LOG" # Append to log file (stripping color codes)
}

function notify() {
  if command -v notify-send &>/dev/null && [[ -n "${DISPLAY:-}" ]]; then
    notify-send "PGS OCR Pipeline" "$1"
  else
    log_msg "${YELLOW}[!] Desktop notification unavailable${NC}" # Use log_msg for consistency
  fi
  # Log the notification message using log_msg, which now handles both stdout and file logging
  log_msg "${BLUE}[ðŸ””] $1${NC}"
}

# â”€â”€ Initial Scan Message â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
log_msg "${BLUE}â”€ Starting OCR scan in: $ROOT â”€${NC}"

# â”€â”€ Dependency Check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
log_msg "${BLUE}â”€ Checking CLI dependencies â”€${NC}"
missing_cli=()
for pkg in "${CLI_DEPS[@]}"; do
  # Check if package is installed using dpkg
  dpkg -s "$pkg" &>/dev/null || missing_cli+=("$pkg")
done

if (( ${#missing_cli[@]} )); then
  log_msg "${YELLOW}[+] Installing missing CLI packages: ${missing_cli[*]}${NC}"
  # Install missing packages non-interactively
  sudo DEBIAN_FRONTEND=noninteractive apt install -y "${missing_cli[@]}" >> "$LOG" 2>&1
  if [ $? -ne 0 ]; then
    log_msg "${RED} [FAIL] Failed to install CLI dependencies. Exiting.${NC}"
    exit 1
  fi
else
  log_msg "${GREEN}[OK] All CLI dependencies present${NC}" # ASCII checkmark
fi

# â”€â”€ Build sup2srt if missing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
log_msg "${BLUE}â”€ Checking for sup2srt â”€${NC}"
if ! command -v sup2srt &>/dev/null; then
  log_msg "${RED}[!] sup2srt not found. Attempting to build...${NC}"

  log_msg "${YELLOW}[+] Installing sup2srt build dependencies${NC}"
  missing_sup2srt_deps=()
  for dep in "${SUP2SRT_DEPS[@]}"; do
    dpkg -s "$dep" &>/dev/null || missing_sup2srt_deps+=("$dep")
  done

  if (( ${#missing_sup2srt_deps[@]} )); then
    sudo DEBIAN_FRONTEND=noninteractive apt install -y "${missing_sup2srt_deps[@]}" >> "$LOG" 2>&1
    if [ $? -ne 0 ]; then
      log_msg "${RED} [FAIL] Failed to install sup2srt build dependencies. Exiting.${NC}"
      exit 1
    fi
  else
    log_msg "${GREEN}[OK] All sup2srt build dependencies present${NC}" # ASCII checkmark
  fi

  log_msg "${TEAL} â†ª Cloning sup2srt repository${NC}"
  git clone https://github.com/retrontology/sup2srt.git /tmp/sup2srt >> "$LOG" 2>&1
  if [ $? -ne 0 ]; then
    log_msg "${RED} [FAIL] Failed to clone sup2srt repository. Exiting.${NC}"
    exit 1
  fi

  log_msg "${TEAL} â†ª Building sup2srt${NC}"
  mkdir -p /tmp/sup2srt/build && cd /tmp/sup2srt/build
  cmake .. >> "$LOG" 2>&1 && make -j"$(nproc)" >> "$LOG" 2>&1 && sudo make install >> "$LOG" 2>&1
  if [ $? -ne 0 ]; then
    log_msg "${RED} [FAIL] Failed to build and install sup2srt. Exiting.${NC}"
    exit 1
  fi
  cd "$ROOT" # Return to the original root directory

  if command -v sup2srt &>/dev/null; then
    log_msg "${GREEN}[OK] sup2srt built and installed successfully${NC}" # ASCII checkmark
  else
    log_msg "${RED} [FAIL] sup2srt still not found after build attempt. Exiting.${NC}"
    exit 1
  fi
else
  log_msg "${GREEN}[OK] sup2srt is already installed${NC}" # ASCII checkmark
fi

# â”€â”€ Main Script Logic Starts Here â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

EXCLUDE_FILE="/mnt/Media/srt_exclude_dirs.txt"
excluded=()
# Read excluded directories into an array if the file exists
[[ -f "$EXCLUDE_FILE" ]] && mapfile -t excluded < "$EXCLUDE_FILE"

# Global array to store full paths of all SRTs that should remain after this run
declare -a processed_srt_paths=()

# Find all MKV files recursively
mapfile -t mkv_list < <(find "$ROOT" -iname "*.mkv")
total=${#mkv_list[@]}
processed=0

for mkvfile in "${mkv_list[@]}"; do
  ((processed++))
  # Calculate percentage complete
  percent=$(( processed * 100 / total ))
  dir=$(dirname "$mkvfile")
  base="$(basename "${mkvfile%.*}")" # Filename without extension
  parent="$(basename "$dir")" # Parent directory name

  echo -e "\n" # Add a newline for better readability between files
  log_msg "${BLUE}âž¤ Processing [$processed/$total] â†’ ${percent}% done${NC}"
  log_msg "${PURPLE} â€¢ $base.mkv${NC}"

  # Check if the parent directory is in the exclusion list
  if printf '%s\n' "${excluded[@]}" | grep -qxF "$parent"; then
    log_msg "${YELLOW} â†ª Directory excluded â†’ Skipping${NC}"
    continue
  fi

  # Check for embedded SRT or ASS tracks using mkvmerge info
  if mkvmerge -i "$mkvfile" | grep -Ei 'subtitles.*(SRT|ASS)' >/dev/null; then
    log_msg "${YELLOW} â†ª Skipped: Embedded SRT/ASS track${NC}"
    continue
  fi

  # Extract English or untagged PGS subtitle tracks using jq for precise filtering
  pgs_tracks=$(mkvmerge -J "$mkvfile" | jq '[.tracks[] | select(.type=="subtitles" and .codec=="HDMV PGS" and (.properties.language == "eng" or .properties.language == null))]')
  mapfile -t track_lines < <(jq -c '.[]' <<< "$pgs_tracks") # Convert JSON array to bash array of lines
  
  # If no usable PGS tracks are found, skip to the next MKV
  [[ ${#track_lines[@]} -eq 0 ]] && {
    log_msg "${RED} [FAIL] No usable English PGS tracks${NC}" # ASCII failure
    continue
  }

  created_subs=() # Initialize array to track created/skipped subtitles for the current MKV
  en_regular_count=0 # IMPORTANT: Reset for each MKV file
  en_forced_count=0  # IMPORTANT: Reset for each MKV file
  en_sdh_count=0     # IMPORTANT: Reset for each MKV file

  for track in "${track_lines[@]}"; do
    id=$(echo "$track" | jq '.id') # Extract track ID
    title=$(echo "$track" | jq -r '.properties.track_name // ""') # Extract track name, default to empty string
    # Extract forced_track and hearing_impaired flags directly from metadata
    forced_flag=$(echo "$track" | jq '.properties.forced_track // false')
    hearing_impaired_flag=$(echo "$track" | jq '.properties.hearing_impaired // false')

    # ðŸ”¤ Suffix inference from track title AND metadata flags
    local_base_suffix=""
    local_is_forced=false
    local_is_sdh=false

    # Prioritize forced flag/title, then SDH flag/title, then regular
    if [[ "$forced_flag" == "true" || "$title" =~ [Ff]orced ]]; then
        local_base_suffix=".en.forced"
        local_is_forced=true
    elif [[ "$hearing_impaired_flag" == "true" || "$title" =~ (SDH|HI|HOH|Hearing Impaired) ]]; then
        local_base_suffix=".en.sdh"
        local_is_sdh=true
    else
        local_base_suffix=".en" # Default for regular English tracks
    fi

    # Determine the final suffix_key based on type and count
    if [ "$local_is_forced" == "true" ]; then
        ((en_forced_count++))
        if [ "$en_forced_count" -eq 1 ]; then
            suffix_key="${local_base_suffix#.}" # "en.forced"
        else
            suffix_key="${local_base_suffix#.}.${en_forced_count}" # "en.forced.2"
        fi
    elif [ "$local_is_sdh" == "true" ]; then
        ((en_sdh_count++))
        if [ "$en_sdh_count" -eq 1 ]; then
            suffix_key="${local_base_suffix#.}" # "en.sdh"
        else
            suffix_key="${local_base_suffix#.}.${en_sdh_count}" # "en.sdh.2"
        fi
    else # Regular English track
        ((en_regular_count++))
        if [ "$en_regular_count" -eq 1 ]; then
            suffix_key="${local_base_suffix#.}" # "en"
        else
            suffix_key="${local_base_suffix#.}.${en_regular_count}" # "en.2"
        fi
    fi

    srt="$dir/$base.$suffix_key.srt" # Proposed SRT filename
    sup="${srt%.srt}.sup" # Corresponding temporary SUP filename

    # Validation block: Check if a valid OCR'd SRT already exists for THIS specific track configuration
    if [[ -f "$srt" ]]; then
      footer=$(tail -n 1 "$srt" 2>/dev/null || echo "") # Get last line, handle empty file
      
      # Use the generic COMMENT for expected_footer comparison
      expected_footer="$COMMENT" 

      # Debugging log:
      # log_msg "${TEAL}  [DEBUG] Validating $srt: Footer='${footer}' Expected='${expected_footer}'${NC}"

      # If the file exists and has our generic comment, it's considered valid and processed
      if [[ "$footer" == "$expected_footer" ]]; then
        log_msg "${YELLOW} â†ª Valid OCR exists â†’ $(basename "$srt")${NC}"
        created_subs+=("Skipped: .$suffix_key.srt") # Store concise skipped info
        processed_srt_paths+=("$srt") # Add to global list of valid SRTs
        continue # Skip to next track
      else
        # If file exists but does NOT have our generic comment, it's an external/invalid file at this path
        log_msg "${ORANGE} â†ª Conflicting untagged SRT found, removing: $(basename "$srt")${NC}"
        rm -f "$srt"
        echo "$(timestamp) [CONFLICT-REMOVED] Removed â†’ $srt" >> "$orphan_log"
      fi
    fi

    # Suffix conflict resolution: This block handles cases where the *generated* SRT name
    # still conflicts with an existing file (e.g., a pre-existing manual file, or an edge case).
    # It appends a further numerical index to ensure uniqueness.
    if [[ -f "$srt" ]]; then
      local current_base_name="$dir/$base.$suffix_key" # e.g., /path/to/movie.en or /path/to/movie.en.forced
      local conflict_index=2
      while [[ -f "${current_base_name}.${conflict_index}.srt" ]]; do
        ((conflict_index++))
      done
      suffix_key="${suffix_key}.${conflict_index}" # Append .2, .3 etc. to the current suffix_key
      srt="$dir/$base.$suffix_key.srt"
      sup="${srt%.srt}.sup"
      log_msg "${ORANGE} â†ª Suffix conflict resolved â†’ Track $id â†’ .$suffix_key${NC}"
    fi

    # ðŸ§ª Extract and OCR process
    log_msg "${TEAL}  â†ª Extracting track $id from .mkv via mkvextract${NC}"
    mkvextract tracks "$mkvfile" "$id:$sup" >> "$LOG" 2>&1
    log_msg "${GREEN}  [OK] Created:${NC} $(basename "$sup")" # ASCII checkmark

    log_msg "${TEAL}  â†ª Converting from .sup (PGS) to .srt (SubRip) via sup2srt${NC}"
    sup2srt -l eng "$sup" -o "$srt" >> "$LOG" 2>&1

    # Retry sup2srt if output is empty or too short (less than 6 lines for a valid SRT)
    if [[ ! -s "$srt" || $(wc -l < "$srt") -lt 6 ]]; then
      log_msg "${ORANGE} â†» Retry: sup2srt fallback (without -l eng) â†’ Track $id${NC}"
      sup2srt "$sup" -o "$srt" >> "$LOG" 2>&1 # Retry without language flag
    fi

    # Final check after OCR attempt
    if [[ -s "$srt" && $(wc -l < "$srt") -gt 5 ]]; then
      block_count=$(grep -cE '^[0-9]+$' "$srt") # Recalculate block count for footer
      # Append only the generic COMMENT to the SRT file
      echo -e "\n9999\n99:59:59,999 --> 99:59:59,999\n$COMMENT" >> "$srt"
      chmod 664 "$srt" && chown "$USER:mediaaccess" "$srt" # Set permissions and ownership
      rm -f "$sup" # Remove temporary SUP file
      log_msg "${GREEN}  [OK] Created:${NC} $(basename "$srt")${NC}" # ASCII checkmark
      created_subs+=(".$suffix_key.srt") # Store concise created info
      processed_srt_paths+=("$srt") # Add to global list of valid SRTs
    else
      log_msg "${RED} [FAIL] OCR failed for Track $id${NC}" # ASCII failure
      rm -f "$sup" # Clean up sup file even on failure
    fi
  done

  # Summarize processing for the current MKV file in the log
  unique_subs=()
  mapfile -t unique_subs < <(printf "%s\n" "${created_subs[@]}" | awk '!seen[$0]++') # Get unique entries
  new_files=()
  for sub in "${unique_subs[@]}"; do
    new_files+=("$sub") # new_files now contains concise "Skipped: .en.forced.srt" or ".en.2.srt"
  done

  if [[ ${#new_files[@]} -gt 0 ]]; then
    log_file_only_msg "[SUMMARY][OCR] $base.mkv â†’ Created: $(IFS=,; echo "${new_files[*]}")"
  elif [[ ${#unique_subs[@]} -gt 0 ]]; then
    log_file_only_msg "[SUMMARY][SKIPPED] $base.mkv â†’ $(IFS=,; echo "${unique_subs[*]}")"
  else
    log_file_only_msg "[SUMMARY][FAILED] $base.mkv â†’ No usable output"
  fi
done

# ðŸ§¹ Final cleanup pass: delete any SRT not in processed_srt_paths (excluding filtered dirs)
log_msg "${BLUE} ðŸ§¹ Final cleanup: Removing extraneous SRTs (excluding filtered directories)${NC}"
cleaned=0
# Find all SRT files in non-excluded directories
find "$ROOT" -type f -iname "*.srt" | while read -r srt_file; do
  # Check if srt_file is in an excluded directory
  srt_parent_dir=$(basename "$(dirname "$srt_file")") # Removed 'local' keyword
  if printf '%s\n' "${excluded[@]}" | grep -qxF "$srt_parent_dir"; then
    continue # Skip excluded directories
  fi

  # Check if this srt_file is NOT in our global list of known valid SRTs from this run
  # This is the core of the "delete if not explicitly kept" logic
  if ! (printf '%s\n' "${processed_srt_paths[@]}" | grep -qxF "$srt_file"); then
    rm -f "$srt_file"
    ((cleaned++))
    echo "$(timestamp) [FINAL-CLEANUP] Deleted â†’ $srt_file" >> "$orphan_log"
  fi
done

if [[ $cleaned -gt 0 ]]; then
  log_msg "${RED} [INFO] Removed $cleaned extraneous SRTs.${NC}" # Changed message to INFO
else
  log_msg "${GREEN}[OK] No extraneous SRTs found for removal.${NC}" # Explicit message if nothing cleaned
fi

# ðŸŽ‰ Completion
notify "Processing complete in $(basename "$ROOT")"
log_msg "${GREEN}[OK] All tasks finished. Log saved to:${NC} $LOG" # ASCII checkmark

