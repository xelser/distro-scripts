#!/bin/bash
clear

ROOT="${1:-$PWD}"
LOG="$ROOT/subtitle_ocr_pipeline.log"
COMMENT="[OCR] Generated by Subtitle OCR Pipeline"
orphan_log="$ROOT/orphaned_srt_audit.log"

SCRIPT_SUCCESS=true

# Colors for terminal output
GREEN='\033[0;32m' ; YELLOW='\033[1;33m' ; BLUE='\033[1;34m'
RED='\033[0;31m'   ; PURPLE='\033[0;35m' ; TEAL='\033[0;36m'
ORANGE='\033[38;5;208m' ; NC='\033[0m'

# Logging functions
timestamp() { date +"[%Y-%m-%d %H:%M:%S]" ; }
log_msg() {
  local msg="$1"
  echo -e "$msg"
  echo -e "$(timestamp) ${msg//$NC/}" >> "$LOG"
}
log_file_only_msg() {
  local msg="$1"
  echo -e "$(timestamp) ${msg//$NC/}" >> "$LOG"
}

# Desktop notification function
function notify() {
  if command -v notify-send &>/dev/null && [[ -n "${DISPLAY:-}" ]]; then
    notify-send "Subtitle OCR Pipeline" "$1"
  else
    log_msg "${YELLOW}[!] Desktop notification unavailable${NC}"
  fi
  log_msg "${BLUE}➤ $1${NC}"
}

# Initial cleanup of old logs
log_msg "${BLUE}─ Cleaning up old log files... ─${NC}"
rm -f "$LOG" "$orphan_log" &>/dev/null
log_msg "${GREEN}✔ Old log files removed.${NC}"

log_msg "${BLUE}─ Starting Subtitle OCR scan in: $ROOT ─${NC}"

# CLI_DEPS: Tools directly used as commands
CLI_DEPS=(mkvtoolnix jq tesseract-ocr libnotify-bin)

# BUILD_DEPS: Libraries and tools required to compile sup2srt from source
BUILD_DEPS=(libtiff5-dev libleptonica-dev libtesseract-dev tesseract-ocr-eng \
            libavcodec-dev libavformat-dev libavutil-dev libavdevice-dev \
            cmake build-essential git libpng-dev zlib1g-dev pkg-config)

# Check and install system dependencies
log_msg "${BLUE}─ Checking and installing system dependencies ─${NC}"
missing_apt_deps=()

for pkg in "${CLI_DEPS[@]}"; do
  dpkg -s "$pkg" &>/dev/null || missing_apt_deps+=("$pkg")
done

for dep in "${BUILD_DEPS[@]}"; do
  dpkg -s "$dep" &>/dev/null || missing_apt_deps+=("$dep")
done

if (( ${#missing_apt_deps[@]} )); then
  log_msg "${YELLOW}[+] Installing missing APT packages: ${missing_apt_deps[*]}${NC}"
  sudo DEBIAN_FRONTEND=noninteractive apt install -y "${missing_apt_deps[@]}" >> "$LOG" 2>&1
  if [ $? -ne 0 ]; then
    log_msg "${RED}✗ Failed to install APT dependencies. Check log for details.${NC}"
    SCRIPT_SUCCESS=false
  fi
  log_msg "${TEAL} ↪ Updating dynamic linker cache (ldconfig)...${NC}"
  sudo ldconfig >> "$LOG" 2>&1
else
  log_msg "${GREEN}✔ All core APT dependencies present.${NC}"
fi

# Build sup2srt if missing
if "$SCRIPT_SUCCESS"; then
  log_msg "${BLUE}─ Checking for sup2srt ─${NC}"
  if ! command -v sup2srt &>/dev/null; then
    log_msg "${RED}[!] sup2srt not found. Attempting to build from source...${NC}"

    if [[ -d "/tmp/sup2srt" ]]; then
      log_msg "${TEAL} ↪ Cleaning up existing /tmp/sup2srt directory...${NC}"
      rm -rf "/tmp/sup2srt" >> "$LOG" 2>&1
    fi

    log_msg "${TEAL} ↪ Cloning sup2srt repository${NC}"
    git clone https://github.com/retrontology/sup2srt.git /tmp/sup2srt >> "$LOG" 2>&1
    if [ $? -ne 0 ]; then
      log_msg "${RED}✗ Failed to clone sup2srt repository. Check log for details.${NC}"
      SCRIPT_SUCCESS=false
    fi

    if "$SCRIPT_SUCCESS"; then
      log_msg "${TEAL} ↪ Building sup2srt${NC}"
      mkdir -p /tmp/sup2srt/build && cd /tmp/sup2srt/build
      cmake .. >> "$LOG" 2>&1 && make -j"$(nproc)" >> "$LOG" 2>&1 && sudo make install >> "$LOG" 2>&1
      if [ $? -ne 0 ]; then
        log_msg "${RED}✗ Failed to build and install sup2srt. Check log for details.${NC}"
        SCRIPT_SUCCESS=false
      fi
      cd "$ROOT"
    fi

    if "$SCRIPT_SUCCESS" && command -v sup2srt &>/dev/null; then
      log_msg "${GREEN}✔ sup2srt built and installed successfully.${NC}"
    elif ! "$SCRIPT_SUCCESS"; then
      log_msg "${RED}✗ sup2srt not installed due to previous errors.${NC}"
    else
      log_msg "${RED}✗ sup2srt still not found after build attempt. Check log for details.${NC}"
      SCRIPT_SUCCESS=false
    fi
  else
    log_msg "${GREEN}✔ sup2srt is already installed.${NC}"
  fi
fi

# Main script logic
if "$SCRIPT_SUCCESS"; then
  EXCLUDE_FILE="/mnt/Media/srt_exclude_dirs.txt"
  excluded=()
  [[ -f "$EXCLUDE_FILE" ]] && mapfile -t excluded < "$EXCLUDE_FILE"

  declare -a processed_srt_paths=()

  mapfile -t mkv_list < <(find "$ROOT" -iname "*.mkv")
  total=${#mkv_list[@]}
  processed=0

  for mkvfile in "${mkv_list[@]}"; do
    ((processed++))
    percent=$(( processed * 100 / total ))
    dir=$(dirname "$mkvfile")
    base="$(basename "${mkvfile%.*}")"
    parent="$(basename "$dir")"

    echo -e "\n"
    log_msg "${BLUE}➤ Processing [$processed/$total] → ${percent}% done${NC}"
    log_msg "${PURPLE} • $base.mkv${NC}"

    if printf '%s\n' "${excluded[@]}" | grep -qxF "$parent"; then
      log_msg "${YELLOW} ↪ Directory excluded → Skipping${NC}"
      continue
    fi

    if mkvmerge -i "$mkvfile" | grep -Ei 'subtitles.*(SRT|ASS)' >/dev/null; then
      log_msg "${YELLOW} ↪ Skipped: Embedded SRT/ASS track${NC}"
      continue
    fi

    # Extract English or untagged PGS subtitle tracks
    pgs_tracks=$(mkvmerge -J "$mkvfile" | jq '[.tracks[] | select(.type=="subtitles" and .codec=="HDMV PGS" and (.properties.language == "eng" or .properties.language == null))]')
    mapfile -t track_lines < <(jq -c '.[]' <<< "$pgs_tracks")
    
    [[ ${#track_lines[@]} -eq 0 ]] && {
      log_msg "${RED}✗ No usable English PGS subtitle tracks${NC}"
      continue
    }

    created_subs=()
    en_regular_count=0
    en_forced_count=0
    en_sdh_count=0

    for track in "${track_lines[@]}"; do
      id=$(echo "$track" | jq '.id')
      codec=$(echo "$track" | jq -r '.codec')
      title=$(echo "$track" | jq -r '.properties.track_name // ""')
      forced_flag=$(echo "$track" | jq '.properties.forced_track // false')
      hearing_impaired_flag=$(echo "$track" | jq '.properties.hearing_impaired // false')

      local_base_suffix=""
      local_is_forced=false
      local_is_sdh=false

      if [[ "$forced_flag" == "true" || "$title" =~ [Ff]orced ]]; then
          local_base_suffix=".en.forced"
          local_is_forced=true
      elif [[ "$hearing_impaired_flag" == "true" || "$title" =~ (SDH|HI|HOH|Hearing Impaired) ]]; then
          local_base_suffix=".en.sdh"
          local_is_sdh=true
      else
          local_base_suffix=".en"
      fi

      if [ "$local_is_forced" == "true" ]; then
          ((en_forced_count++))
          if [ "$en_forced_count" -eq 1 ]; then
              suffix_key="${local_base_suffix#.}"
          else
              suffix_key="${local_base_suffix#.}.${en_forced_count}"
          fi
      elif [ "$local_is_sdh" == "true" ]; then
          ((en_sdh_count++))
          if [ "$en_sdh_count" -eq 1 ]; then
              suffix_key="${local_base_suffix#.}"
          else
              suffix_key="${local_base_suffix#.}.${en_sdh_count}"
          fi
      else
          ((en_regular_count++))
          if [ "$en_regular_count" -eq 1 ]; then
              suffix_key="${local_base_suffix#.}"
          else
              suffix_key="${local_base_suffix#.}.${en_regular_count}"
          fi
      fi

      srt="$dir/$base.$suffix_key.srt"
      temp_files=()
      
      # Check if a valid OCR'd SRT already exists
      if [[ -f "$srt" ]]; then
        footer=$(tail -n 1 "$srt" 2>/dev/null || echo "")
        expected_footer="$COMMENT" 

        if [[ "$footer" == "$expected_footer" ]]; then
          log_msg "${YELLOW} ↪ Valid OCR exists → $(basename "$srt")${NC}"
          created_subs+=("Skipped: .$suffix_key.srt")
          processed_srt_paths+=("$srt")
          continue
        else
          log_msg "${ORANGE} ↪ Conflicting untagged SRT found, removing: $(basename "$srt")${NC}"
          rm -f "$srt"
          echo "$(timestamp) [CONFLICT-REMOVED] Removed: $(basename "$srt")" >> "$orphan_log"
        fi
      fi

      # Suffix conflict resolution
      if [[ -f "$srt" ]]; then
        local current_base_name="$dir/$base.$suffix_key"
        local conflict_index=2
        while [[ -f "${current_base_name}.${conflict_index}.srt" ]]; do
          ((conflict_index++))
        done
        suffix_key="${suffix_key}.${conflict_index}"
        srt="$dir/$base.$suffix_key.srt"
      fi

      # Extract and OCR PGS subtitle
      log_msg "${TEAL}  ↪ Extracting track $id ($codec) from .mkv via mkvextract${NC}"
      if [[ "$codec" == "HDMV PGS" ]]; then
        temp_sup="${srt%.srt}.sup"
        mkvextract tracks "$mkvfile" "$id:$temp_sup" >> "$LOG" 2>&1
        log_msg "${GREEN}  ✔ Created:${NC} $(basename "$temp_sup")"
        log_msg "${TEAL}  ↪ Converting from .sup (PGS) to .srt (SubRip) via sup2srt${NC}"
        sup2srt -l eng "$temp_sup" -o "$srt" >> "$LOG" 2>&1
        if [[ ! -s "$srt" || $(wc -l < "$srt") -lt 6 ]]; then
          log_msg "${ORANGE} ↻ Retry: sup2srt fallback (without -l eng) → Track $id${NC}"
          sup2srt "$temp_sup" -o "$srt" >> "$LOG" 2>&1
        fi
        temp_files+=("$temp_sup")
      else
        log_msg "${RED}✗ Unsupported codec '$codec' for track $id. Skipping OCR for this track.${NC}"
        continue
      fi

      # Final check after OCR attempt
      if [[ -s "$srt" && $(wc -l < "$srt") -gt 5 ]]; then
        echo -e "\n9999\n99:59:59,999 --> 99:59:59,999\n$COMMENT" >> "$srt"
        chmod 664 "$srt" && chown "$USER:mediaaccess" "$srt"
        
        for temp_file in "${temp_files[@]}"; do
          rm -f "$temp_file"
        done
        log_msg "${GREEN}  ✔ Created:${NC} $(basename "$srt")${NC}"
        created_subs+=(".$suffix_key.srt")
        processed_srt_paths+=("$srt")
      else
        log_msg "${RED}✗ OCR failed for Track $id ($codec). Check log for details.${NC}"
        SCRIPT_SUCCESS=false
        for temp_file in "${temp_files[@]}"; do
          rm -f "$temp_file"
        done
      fi
    done

    # Summarize processing for the current MKV file
    unique_subs=()
    mapfile -t unique_subs < <(printf "%s\n" "${created_subs[@]}" | awk '!seen[$0]++')
    new_files=()
    for sub in "${unique_subs[@]}"; do
      new_files+=("$sub")
    done

    if [[ ${#new_files[@]} -gt 0 ]]; then
      log_file_only_msg "[SUMMARY][OCR] $base.mkv → Created: $(IFS=,; echo "${new_files[*]}")"
    elif [[ ${#unique_subs[@]} -gt 0 ]]; then
      log_file_only_msg "[SUMMARY][SKIPPED] $base.mkv → $(IFS=,; echo "${unique_subs[*]}")"
    else
      log_file_only_msg "[SUMMARY][FAILED] $base.mkv → No usable output"
    fi
  done

  # Final cleanup pass: delete any SRT not in processed_srt_paths
  log_msg "${BLUE} 🧹 Final cleanup: Removing extraneous SRTs (excluding filtered directories)${NC}"
  cleaned=0
  find "$ROOT" -type f -iname "*.srt" | while read -r srt_file; do
    srt_parent_dir=$(basename "$(dirname "$srt_file")")
    if printf '%s\n' "${excluded[@]}" | grep -qxF "$srt_parent_dir"; then
      continue
    fi

    if ! (printf '%s\n' "${processed_srt_paths[@]}" | grep -qxF "$srt_file"); then
      rm -f "$srt_file"
      echo "$(timestamp) [FINAL-CLEANUP] Deleted: $(basename "$srt_file")" >> "$orphan_log"
    fi
  done

  if [[ $cleaned -gt 0 ]]; then
    log_msg "${RED} [INFO] Removed $cleaned extraneous SRTs.${NC}"
  else
    log_msg "${GREEN}✔ No extraneous SRTs found for removal.${NC}"
  fi
else
  log_msg "${RED}✗ Skipping main OCR processing due to previous dependency/build failures.${NC}"
fi

# Completion message
if "$SCRIPT_SUCCESS"; then
  notify "Processing complete in $(basename "$ROOT")"
  log_msg "${GREEN}✔ All tasks finished successfully. Log saved to:${NC} $LOG"
else
  notify "Processing finished with errors in $(basename "$ROOT")"
  log_msg "${RED}✗ Script finished with errors. Check the log file ($LOG) for details.${NC}"
fi

